<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="垚"><title>LRU 与 LFU 缓存算法 · 无存在感小透明</title><meta name="description" content="LRU概念LRU 是最近最少使用 Least Recently Used 的缩写。一种常用的页面置换算法，常用来设计缓存。
每次缓存空间不足时，选择缓存中最久没有使用的缓存进行删除，然后写入新的缓存。
获取数据 get(key) 方法：如果密钥 key 存在于缓存中，则获取对应的 value 并将这"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:140px;"><h3 title=""><a href="/">无存在感小透明</a></h3><div class="description"><p>(✿╹◡╹) 相信的心就是你的魔法 (╹◡╹✿)</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/dongshunyao" target="_blank" rel="noopener"><i class="fa fa-twitter"></i></a></li><li><a href="https://github.com/dongshunyao" target="_blank" rel="noopener"><i class="fa fa-github"></i></a></li><li><a href="https://t.me/yao2333" target="_blank" rel="noopener"><i class="fa fa-telegram"></i></a></li><li><a href="mailto:dongshunyao@qq.com"><i class="fa fa-envelope"></i></a></li><li><a href="/rss2.xml"><i class="fa fa-rss"></i></a></li><li><a href="/atom.xml"><i class="fa fa-rss-square"></i></a></li></ul><div class="footer"><span>Time To</span><div class="by_farbox"><span>Mix Drink && Change Life</span></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">文章</a></li><li><a href="/about">关于</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h2><a>LRU 与 LFU 缓存算法</a></h2></div><div class="post-content"><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>LRU 是最近最少使用 Least Recently Used 的缩写。一种常用的页面置换算法，常用来设计缓存。</p>
<p>每次缓存空间不足时，选择缓存中最久没有使用的缓存进行删除，然后写入新的缓存。</p>
<p>获取数据 get(key) 方法：如果密钥 key 存在于缓存中，则获取对应的 value 并将这个缓存标记为访问，否则返回 -1。</p>
<p>写入数据 put(key, value) 方法：如果密钥 key 不存在，则写入其 value。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的缓存，然后进行写入。</p>
<h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>为了保证 get 和 put 都是 O(1) 的，这里用双向链表+哈希表进行构建。双向链表修改时 O(1) ，使用单链表的话修改是 O(n) 的。</p>
<p>哈希表用于 O(1) 的进行 get 操作，双向链表用于维护时间的访问顺序，一旦访问了就将这个节点移动到链表头。</p>
<p>get 操作时，找到了就将节点移动到链表头并返回 value 值，否则返回 -1。</p>
<p>put 操作时，如果此时缓存已经满了，就先移除最久没有使用的缓存，也就是链表的尾节点，并删除哈希表的对应位置。然后进行插入，新节点被放置在链表头部。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">Leetcode 146 LRU缓存机制</a></p>
<p>这里是双向链表是手写的，所以需要一个头结点和尾节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">int</span> val;</span><br><span class="line">		<span class="keyword">int</span> key;</span><br><span class="line">		node* pre;</span><br><span class="line">		node* next;</span><br><span class="line"></span><br><span class="line">		node(): val(<span class="number">0</span>), key(<span class="number">0</span>), pre(<span class="literal">nullptr</span>), next(<span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	node* head;</span><br><span class="line">	node* tail;</span><br><span class="line">	<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, node*&gt; <span class="built_in">map</span>;</span><br><span class="line">	<span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addNode</span><span class="params">(node* node)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		node-&gt;next = head-&gt;next;</span><br><span class="line">		node-&gt;pre = head;</span><br><span class="line">		head-&gt;next-&gt;pre = node;</span><br><span class="line">		head-&gt;next = node;</span><br><span class="line">		<span class="built_in">map</span>[node-&gt;key] = node;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(node* node, <span class="keyword">bool</span> del)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		node-&gt;pre-&gt;next = node-&gt;next;</span><br><span class="line">		node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line">		<span class="keyword">if</span> (del)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">map</span>.erase(node-&gt;key);</span><br><span class="line">			<span class="keyword">delete</span> node;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(node* node)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		deleteNode(node, <span class="literal">false</span>);</span><br><span class="line">		addNode(node);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	LRUCache(<span class="keyword">int</span> capacity)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">		head = <span class="keyword">new</span> node();</span><br><span class="line">		tail = <span class="keyword">new</span> node();</span><br><span class="line">		head-&gt;next = tail;</span><br><span class="line">		tail-&gt;pre = head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~LRUCache()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">auto</span> temp = head;</span><br><span class="line">			head = head-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">map</span>.count(key) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">auto</span> node = <span class="built_in">map</span>[key];</span><br><span class="line">		moveToHead(node);</span><br><span class="line">		<span class="keyword">return</span> node-&gt;val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">map</span>.count(key) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">auto</span> temp = <span class="keyword">new</span> node();</span><br><span class="line">			temp-&gt;key = key;</span><br><span class="line">			temp-&gt;val = value;</span><br><span class="line">			addNode(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">auto</span> temp = <span class="built_in">map</span>[key];</span><br><span class="line">			temp-&gt;val = value;</span><br><span class="line">			moveToHead(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">map</span>.size() &gt; capacity) deleteNode(tail-&gt;pre, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>最不经常使用算法。这个缓存算法使用一个计数器来记录每个缓存的使用次数，缓存满时选择使用次数最低的且是最久没有使用的缓存进行删除。</p>
<p>这个方法并不经常使用，因为它无法对一个拥有最初高访问率之后长时间没有被访问的缓存负责。</p>
<p>获取数据 get(key) 方法：如果密钥 key 存在于缓存中，则获取对应的 value 并将这个缓存的使用次数 +1，否则返回 -1。</p>
<p>写入数据 put(key, value) 方法：如果密钥 key 存在，则修改对应的 value 值，并把使用次数 +1。如果密钥 key 不存在，先判断缓存是否已经满了，如果满了，则删除最小使用次数中最久没有访问的缓存，然后再写入这个 key 对应 value ，并设置访问次数为 1 。</p>
<h4 id="设计-1"><a href="#设计-1" class="headerlink" title="设计"></a>设计</h4><p>这里使用的了两个哈希表，保证 get 和 put 都是 O(1) 的。</p>
<p>一个哈希表用于存放 key 和节点的对应关系，用于 O(1) 的进行 get 操作。</p>
<p>一个哈希表以使用次数为 key ，以一个双向链表为 value 。每一个双向链表类似于 LRU ，按时间顺序存放这个使用次数下的节点，最新的在链表头，最久没有访问的在链表尾。</p>
<p>然后还需要一个变量记录当前最小的使用次数。</p>
<p>第二个哈希表可以用一个双向链表替代，效果不变。</p>
<p>get 操作时，找到了就将节点从当前的链表移除，并将使用次数 +1 ，然后放置在此时对应的使用次数的链表头部（这个时候如果旧的链表已经空了，需要删除空链表，同时判断最小使用次数是否需要更新）并返回 value 值，否则返回 -1。</p>
<p>put 操作时，<strong>先看能不能找到这个 key</strong> ：</p>
<ul>
<li><p>能找到：<strong>修改对应的 value ，然后将节点从当前的链表移除，并将使用次数 +1 ，然后放置在此时对应的使用次数的链表头部</strong>（这个时候如果旧的链表已经空了，需要删除空链表，同时判断最小使用次数是否需要更新）并更新哈希表，这个操作类似与 get 。（这里不能删掉现有的然后插入一个使用次数为 1 的节点）</p>
</li>
<li><p>找不到：先看缓存是否已经满了，满了则删除最小使用次数对应的链表的尾部节点。然后进行插入，设置使用次数为 1 ，并更新最小使用次数和哈希表。</p>
</li>
</ul>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p><a href="https://leetcode-cn.com/problems/lfu-cache/" target="_blank" rel="noopener">Leetcode 460 LFU缓存</a></p>
<p>这里使用的是双哈希表，使用了 list 作为双向链表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">int</span> key;</span><br><span class="line">		<span class="keyword">int</span> value;</span><br><span class="line">		<span class="keyword">int</span> freq;</span><br><span class="line"></span><br><span class="line">		Node(<span class="keyword">int</span> key, <span class="keyword">int</span> value, <span class="keyword">int</span> freq)</span><br><span class="line">			: key(key), value(value), freq(freq)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> capacity;</span><br><span class="line">	<span class="keyword">int</span> minFreq;</span><br><span class="line">	<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;Node&gt;::iterator&gt; hash;</span><br><span class="line">	<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;Node&gt;&gt; freqMap;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addFreq</span><span class="params">(<span class="keyword">const</span> <span class="built_in">list</span>&lt;Node&gt;::iterator&amp; now)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">auto</span> key = now-&gt;key, value = now-&gt;value, freq = now-&gt;freq;</span><br><span class="line">		eraseNode(now);</span><br><span class="line"></span><br><span class="line">		freqMap[freq + <span class="number">1</span>].emplace_front(key, value, freq + <span class="number">1</span>);</span><br><span class="line">		hash[key] = freqMap[freq + <span class="number">1</span>].begin();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">eraseNode</span><span class="params">(<span class="built_in">list</span>&lt;Node&gt;::iterator now)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">auto</span> key = now-&gt;key, freq = now-&gt;freq;</span><br><span class="line">		hash.erase(key);</span><br><span class="line">		freqMap[freq].erase(now);</span><br><span class="line">		<span class="keyword">if</span> (freqMap[freq].empty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (freq == minFreq) minFreq++;</span><br><span class="line">			freqMap.erase(freq);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	LFUCache(<span class="keyword">int</span> capacity)</span><br><span class="line">		: capacity(capacity), minFreq(<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (capacity == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span> (hash.count(key) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">auto</span> value = hash[key]-&gt;value;</span><br><span class="line">		addFreq(hash[key]);</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (capacity == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (hash.count(key) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (hash.size() == capacity) eraseNode(--freqMap[minFreq].end());</span><br><span class="line"></span><br><span class="line">			freqMap[<span class="number">1</span>].emplace_front(key, value, <span class="number">1</span>);</span><br><span class="line">			hash[key] = freqMap[<span class="number">1</span>].begin();</span><br><span class="line">			minFreq = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			hash[key]-&gt;value = value;</span><br><span class="line">			addFreq(hash[key]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache* obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-04-19</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Leetcode/" title="Leetcode">Leetcode </a></div></div></div></div><div class="share"><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="https://twitter.com/intent/tweet?url=https://ry.huaji.store/2020/04/Leetcode-LRU-LFU/&amp;text=LRU 与 LFU 缓存算法 · 无存在感小透明" target="_blank" rel="noopener"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2020/05/Leetcode-50/" title="快速幂">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2020/04/JavaEE-03/" title="Java EE 03：Spring Web MVC 分析与流程">下一篇</a></li></ul></div><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><span class="leancloud_visitors" id="/2020/04/Leetcode-LRU-LFU/" data-flag-title="LRU 与 LFU 缓存算法"></span><script src="//cdn.jsdelivr.net/npm/leancloud-storage@4.15.2/dist/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine@1.5.3/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  appId:'CV2PYOHXSB2oApmkqHGUKSzj-MdYXbMMI',
  appKey:'RcyttO7brDSawuxt4FfSUtPM',
  placeholder:'中国有句古话叫「闷声大发财」，但是见到你们这样热情，一句话不说也不好，你说是吧？',
  avatar:'identicon',
  visitor:'true',
  recordIP:'true',
  serverURLs:'https://valine.huaji.store',
  meta:['nick','mail','link'],
  requiredFields:['nick','mail']
})

</script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>